<section>
<h1 id='overview'>欢迎来到BKE的世界！</h1>
<hr>
<p>这里是BKEngine的文档中心，在这里，我们会持续地更新BKE的相关教学文档。您可以访问我们的主页获取更多有关BKE的信息：</p>
<p><a href="http://bke.bakery.moe">http://bke.bakery.moe</a></p>
<p>或者是在我们的论坛/交流群与其他的用户进行交流：</p>
<p><a href="http://bbs.bakery.moe">http://bbs.bakery.moe</a></p>
<p>交流群地址：<a target="_blank" href="http://shang.qq.com/wpa/qunwpa?idkey=dfa55730bc97ce7f8c2ab0943300560b67ec37d8c51c0b48d844fe0ca5d3d348"><img border="0" src="http://pub.idqqimg.com/wpa/images/group.png" alt="BKEngine支援群" title="BKEngine支援群"></a></p>
</section>

<section>
<h1 id='beginner'>新手教学</h1>
<hr />
<p>欢迎观看BKEngine（以下简称为BKE）的新手教学。本教学的目的是让您在几步简单的学习步骤后，制作出一个简单的BKE游戏，从而对本引擎有一个基础的了解。</p>

<h2 id='beginner-bkc'>BKE Creator</h2>
<p>在进行新手教学之前，请确认您已经从NPC的村长那里领到了您的新手装备！<a href="../download/BKECreator/BKECreator.7z">点击这里</a>下载BKE Creator，并将其解压到您硬盘的某处。</p>
<pre><code>警告：如果您直接从压缩包中运行它，BKE Creator可能将不会正常工作。
</code></pre>

<p>现在我们已经拿到了我们的新手装备，在开始制作新游戏之前，我们应该花点时间来熟悉熟悉它。 </p>
<p>BKE Creator能让您创建、管理、编辑或是运行你的BKE游戏。</p>
<p>点击 <code>BKE Creator.exe</code>，来启动BKE Creator。 </p>
<pre><code>提示：在Windows系统下，第一次启动BKE Creator速度可能较慢。
</code></pre>

<p>如果一切正常的话，您会看到这样的界面：</p>
<p><img src="guide/images/2.jpg" img/></p>
<p>这就是BKE的默认编辑器BKE Creator。让我们来新建一个BKE工程试试看。</p>
<p>点击“文件”菜单，选择里面的“新建项目”，编辑器会提醒您输入项目名称，以及选择项目保存的路径，在新手教学中，我们给这个项目起名为tutorial（当然，你也可以自己起一个喜欢的名字）。</p>
<p><img src="guide/images/3.jpg" img /></p>
<p>大功告成！这样，我们就建立了自己的第一个BKE游戏。</p>
<p>不过说是“游戏”，其实现在的它并没有包含一个游戏所需的任何要素——文本、图像、音乐。接下来我们的任务，就是学习怎样让引擎显示文字。</p>
<p>但少安毋躁，在学习让引擎显示文字之前，我们还需要先了解一些基本知识。</p>
<p>点击左侧的项目名，您可以看到项目下的“初始化”子项，里面有以下三个文件—— <code>main.bkscr</code> 、 <code>config.bkpsr</code> 和 <code>macro.bkscr</code> 。</p>
<pre><code>提示：“.bkscr”后缀，就是BKE的脚本文件格式。
</code></pre>

<p>双击 <code>config.bkpsr</code> ，对游戏的标题、分辨率等一系列参数进行设置。为了配合后面的教程，在这里我们将游戏的分辨率设置为1280×720。游戏名称和标题您可以依照自己的喜好来输入，在本教程中我们输入的是 “BKE Tutoial” 。</p>
<p><img src="guide/images/4.jpg" img /></p>
<p>在设置完成后，我们来了解下BKE的基本脚本组成：</p>
<p>&emsp;&emsp;<code>main.bkscr</code>：每个BKE项目都必须拥有这个脚本。它是游戏主程序的入口，解释器会从这个脚本开始运行。<br>
&emsp;&emsp;<code>macro.bkscr</code>：负责管理自定义函数的脚本，仅可以在本脚本内导入（import）其它的脚本。（关于import的知识会在后面会有详细介绍，现在只做一个基础的了解即可。）</p>
<p>除这两者之外的其它脚本都是用户自己编写的脚本，包括自定义函数的脚本、剧本、变量设置等。在BKE Creator中，当您编写好自己的游戏脚本后，可以点击编辑器底部的编译按钮对脚本进行错误检测，并使用运行按钮运行您自己的游戏。</p>
<p><img src="guide/images/5.jpg" img /></p>
<p>底部五个图片按钮从左至右分别是：编译、编译并运行、运行、调试和清理编译项目。</p>
<p>在了解了这些前置知识之后，现在我们可以正式开始游戏的制作了。</p>
<h2 id='beginner-intro'>一个文字组成的游戏</h2>
<p>开始制作之前，请点击<a href="guide/resources/Material.zip">这里</a>下载制作这个演示游戏所需的素材。</p>
<pre><code>*main
【凉子】[r]
抱歉，等很久了么？？[p]
【真由】[r]
啊，真是的，凉子你怎么那么慢？[p]
</code></pre>

<p>上面就是一个最简单的BKE游戏的示例，虽然它既没有图像也没有音乐，但是它确实是一个完整的小故事。</p>
<p>第一行是一个以“*”开头的英文单词。在BKE中，以“*”开头的行我们称之为“标签”。标签的作用是使用一个名称来标记脚本中的一个位置，以便解释器跳转。上面的例子中，我们在 <code>main.bascr</code> 文件中创建了一个名叫“main”的标签。在BKE中， <code>main</code> 标签是一个特殊的存在。BKE主程序的默认入口是 <code>main.bascr</code> 文件中的 <code>main</code> 标签，所以一个新的BKE游戏必须要拥有一个 <code>main</code> 标签。如果您没有创建 <code>main</code> 标签的话，编译器将会报警。 </p>
<p>在例子中，我们可以看到在屏幕上显示的文字，以及一些被半角中括号框起来的文字。在BKE中，所有被半角中括号框起来的文字以及“@”符号之后的文字都会被解释器识别为命令，除此之外的所有东西（“#”符号例外，我们将会在后面解释）都会被视作文字打印在屏幕上。不过需要注意的是，以“@”符号声明的命令必须单独存在，前后都不能有除命令之外的东西存在,比如例子中的 <code>[p]</code> 就不能替换为 <code>@p</code> 。</p>
<p>上面例子中的“r”、“p”命令的功能分别是：<br>
&emsp;&emsp;r&emsp;&emsp;手动换行<br>
&emsp;&emsp;p&emsp;&emsp;换页等待，点击后换页<br></p>
<p>另外还有“l”命令，它的功能是：<br>
&emsp;&emsp;l&emsp;&emsp;等待点击</p>
<p>您可以使用中括号框起来的写法，也可以使用以“@”开头的写法，或是两者兼而有之，这完全取决于您的喜好。</p>
<h2 id='beginner-image'>图像</h2>
<p>让我们来为我们的游戏加上点图像。</p>
<pre><code>*main

[sprite index=0 file=&quot;image/bg/bg441a_1280&quot;]
[addto index=0 target=basic_layer pos=[0,0] zorder=0 opacity=255]


【凉子】[r]
抱歉，等很久了么？？[p]
【真由】[r]
啊，真是的，凉子你怎么那么慢？[p]
</code></pre>

<p>将上面的代码更新到您的 <code>main.bkscr</code> 文件中，保存并编译，您就可以看见新的效果了——游戏拥有了背景画面。（但是同时，我们的文字也看不清了。不过别担心，我们会在后面解决这个问题）</p>
<p>在原有的对话之上，可以看到多出了新的两行命令。这两行命令就是用于添加图像的命令。在游戏里，无论是背景还是立绘，或是漫天飞舞的樱花花瓣，它们的本质都是图像；在BKE中，我们将这些图像统称为 <code>精灵</code> （sprite）。在将精灵添加到屏幕上之前，我们需要先声明它们，Sprite在BKE中同时也是用于声明精灵的命令，它的格式如下：</p>
<p>&emsp;&emsp;<strong>sprite</strong> <em>*index *file rect</em><br>
&emsp;&emsp;&emsp;&emsp;创建一个精灵。</p>
<p>&emsp;&emsp;&emsp;&emsp;<em>index</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;将要创建精灵的编号。<br>
&emsp;&emsp;&emsp;&emsp;<em>file<em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;用于创建精灵的图片文件。<br>
&emsp;&emsp;&emsp;&emsp;</em>rect</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;截取的图片范围。</p>
<p>（带*的项为必须存在的参数名，其余的参数为可选参数，下同）</p>
<p>在上面的第二行，我们就使用了 <code>sprite</code> 命令声明了一张图像。它的编号（index）是0号，图像文件是image/bg/文件夹下的bg441a_1280——等等，后缀名哪去了？<br>
BKE有很多人性化的地方，这就是其中之一。您可以不填写图像的后缀名，交由BKE来自动搜索，一旦BKE搜索到了符合名称的文件，就会自动使用这个文件。如果您在之前的 <code>config.bkpsr</code> 中指定了搜索图像文件的文件夹，那么您甚至可以不写图像的所在文件夹。</p>
<pre><code>提示：如果存在不同后缀名的同名文件，BKE的搜索顺序是PNG&gt;JPG&gt;BMP。
</code></pre>

<p>在声明了精灵后，接下来的步骤就是将它添加到屏幕上。第三行的 <code>addto</code> 命令作用就是将精灵添加到指定的位置。下面是这个命令的格式：</p>
<p>&emsp;&emsp;<strong>addto</strong> <em>*index *target zorder pos opacity</em><br>
&emsp;&emsp;&emsp;&emsp;添加一个精灵（源精灵）到另一个层或精灵（目标精灵）上。</p>
<p>&emsp;&emsp;&emsp;&emsp;<em>index</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;源精灵的编号。<br>
&emsp;&emsp;&emsp;&emsp;<em>file<em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;目标精灵/层的编号/名称。<br>
&emsp;&emsp;&emsp;&emsp;</em>zorder</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;精灵的深度，默认为0。<br>
&emsp;&emsp;&emsp;&emsp;<em>pos</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;叠加的坐标，默认为[0,0]。<br>
&emsp;&emsp;&emsp;&emsp;<em>opacity</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;精灵的不透明度，默认为255。<br></p>
<p>在第二行用 <code>sprite</code> 声明了一个精灵后，第三行我们使用 <code>addto</code> 命令将其添加到了 <strong><code>basic_layer</code></strong> 这个层上。层级可以是用户自己定义的，也可以是BKE中默认定义的层。在BKE中，预先定义的层有两个，它们分别是 <strong><code>basic_layer</code></strong> 和 <strong><code>message_layer</code></strong> 。前者是基础层，后者是用于显示文字消息的层。它们的默认属性如下：</p>
<p>&emsp;&emsp;&emsp;&emsp;<strong>basic_layer</strong> <em>index</em>=-1 <em>zorder</em>=0<br>
&emsp;&emsp;&emsp;&emsp;<strong>message_layer</strong> <em>index</em>=-2 <em>zorder</em>=50<br></p>
<p>例子里面，我们将图片的 <code>zorder</code> 设置为了0。<br>
在BKE中，对于处于同一层级的精灵来说， <code>zorder</code> 的值越大，精灵的显示位置就越靠前；对于不同层级的精灵来说，如果A精灵所在层级的 <code>zorder</code>要低于B精灵所在的层级，那么无论怎样增加A精灵的 <code>zorder</code> 值，A精灵都不可能显示在B精灵之前；对于同层级同 <code>zorder</code> 的精灵来说，后添加者在上。<br>
在看完剩余的命令参数解释后，您可以自行添加一些图片到屏幕上，以更好的理解精灵的层级关系。</p>
<p>因为添加的图片是背景文件，所以我们将它的显示座标设置为0,0， 以便于让图片正确的覆盖整个背景。但严格的来说，这个0,0其实并不是指屏幕的左上角，而是指的是相对于 <strong><code>basic_layer</code></strong> 的偏移量。对于初学者而言，我们建议您将所有的目标层都设置为 <strong><code>basic_layer</code></strong> ，这样的话，所有的坐标都是相对于左上角原点0,0来计算的（即和通常的坐标轴没有任何区别）。</p>
<p>最后一个参数是精灵的不透明度，值的范围从0到255，值越大越不透明。例子中的精灵是完全不透明的。</p>
<p>在了解了声明精灵和添加精灵之后，我们就可以如法炮制，再添加几个其它的精灵了。现在让我们添加上角色的立绘图像。</p>
<pre><code>*main

[sprite index=0 file=&quot;image/bg/bg441a_1280&quot;]
[addto index=0 target=basic_layer pos=[0,0] zorder=0 opacity=255]

[sprite index=1 file=&quot;image/character/A/2_happy&quot;]
[addto index=1 target=basic_layer zorder=10 pos=[400,120] opacity=255]
[sprite index=2 file=&quot;image/character/B/7_wordless&quot;]
[addto index=2 target=basic_layer zorder=10 pos=[640,120] opacity=255]

【凉子】[r]
抱歉，等很久了么？？[p]
【真由】[r]
啊，真是的，凉子你怎么那么慢？[p]
</code></pre>

<p>完成了！现在它看起来更像一个游戏了——除了我们的文字显示，它还有一点小小的问题，我们会在接下来的小节里修复这个问题。</p>
<h2 id='beginner-word'>文字</h2>
<p>BKE自带了一个基础的对话框，但是默认并没有使用。现在我们需要做的就是启用这个基础的对话框，让对话文字正确显示在其中。</p>
<p>点击BKE Creator左侧视图中的 <code>macro.bkscr</code> ，编辑其中的内容：</p>
<pre><code>*register
[import file=&quot;extend.bkscr&quot;]
[return]
</code></pre>

<p>在 <code>macro.bkscr</code> 中，首行必须是名为 <code>register</code> 的标签，下面声明了要引用和定义的宏（Macro）文件。</p>
<pre><code>宏的定义：宏（Macro），是一种批量批量处理的称谓。它将小命令或动作转化为一系列指令。
</code></pre>

<p>在这里，我们引用了一个名为<code>extend.bkscr</code>的文件。成功声明引用后，我们就可以使用这个宏文件内预定义的命令了。</p>
<p>请<a href="guide/download/extend.bkscr">点击这里</a>下载使用到的宏文件。</p>
<p>在左侧视图的“脚本”处点击右键，选择“添加文件”，然后在随后弹出的窗口内选择刚才下载的<code>extend.bkscr</code>。</p>
<p>修改 <code>main.bkscr</code> 文件，在第二行处加上 <code>extend.bkscr</code> 内定义好的设置对话框命令。</p>
<pre><code>*main
[basic_dialogbox]//使用预定义的命令
//在BKE中，以//开头的行都会被视为注释
[sprite index=0 file=&quot;image/bg/bg441a_1280&quot;]
[addto index=0 target=basic_layer pos=[0,0] zorder=0 opacity=255]

[sprite index=1 file=&quot;image/character/A/2_happy&quot;]
[addto index=1 target=basic_layer zorder=10 pos=[400,120] opacity=255]
[sprite index=2 file=&quot;image/character/B/7_wordless&quot;]
[addto index=2 target=basic_layer zorder=10 pos=[640,120] opacity=255]

【凉子】[r]
抱歉，等很久了么？？[p]
【真由】[r]
啊，真是的，凉子你怎么那么慢？[p]
</code></pre>

<p>保存并编译运行，现在文字已经正确的显示在了对话框中了。</p>
<p><img src="guide/images/6.jpg" img /></p>
<h2 id='beginner-sound'>声音、音乐和音效</h2>
<p>许多视觉小说都需要音乐来渲染气氛。在BKE中，音乐有三种：背景音乐、音效、语音。分为三种并不是说它们本质上有什么区别，而是BKE处理它们的方式不同。让我们来看看BKE对于这三种不同音乐的处理方式：</p>
<p>&emsp;&emsp;<strong>bgm</strong> <em>*file loop vol fadein loopto</em><br>
&emsp;&emsp;&emsp;&emsp;播放背景音乐。</p>
<p>&emsp;&emsp;&emsp;&emsp;<em>file</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;将要载入并播放的音频文件。<br>
&emsp;&emsp;&emsp;&emsp;<em>loop<em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;是否循环，默认为<code>false</code>。<br>
&emsp;&emsp;&emsp;&emsp;</em>vol</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;音量，默认为100。<br>
&emsp;&emsp;&emsp;&emsp;<em>fadein</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;淡入的时间，默认为0。<br>
&emsp;&emsp;&emsp;&emsp;<em>loopto</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;设立循环起始点，单位毫秒，默认为0。<br>
<br></p>
<p>&emsp;&emsp;<strong>se</strong> <em>*file channel vol fadein loop</em><br>
&emsp;&emsp;&emsp;&emsp;播放音效。</p>
<p>&emsp;&emsp;&emsp;&emsp;<em>file</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;将要载入并播放的音频文件。<br>
&emsp;&emsp;&emsp;&emsp;<em>channel<em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;指定声音播放的通道编号，默认为0。<br>
&emsp;&emsp;&emsp;&emsp;</em>vol</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;音量，默认为100。<br>
&emsp;&emsp;&emsp;&emsp;<em>fadein</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;淡入的时间，默认为0。<br>
&emsp;&emsp;&emsp;&emsp;<em>loop</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;是否循环，默认为<code>false</code>。<br></p>
<p><br>
&emsp;&emsp;<strong>voice</strong> <em>*file vol</em><br>
&emsp;&emsp;&emsp;&emsp;播放语音。</p>
<p>&emsp;&emsp;&emsp;&emsp;<em>file</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;将要载入并播放的音频文件。<br>
&emsp;&emsp;&emsp;&emsp;<em>vol</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;音量，默认为100。<br></p>
<p>对于背景音乐，BKE可以设置它的循环起始点，这意味着你可以直接截取音频文件的某一段作为背景音乐播放，而不用对其进行任何的处理。对于音效文件，BKE则需要用户自行指定其播放的通道，而背景音乐和语音都有自己默认的声音通道，它们分别是是 <code>bgm</code> 和 <code>voice</code> 。</p>
<p>音乐可以通过stop命令来停止播放。</p>
<p>&emsp;&emsp;<strong>stop</strong> <em>channel fadeout</em><br>
&emsp;&emsp;&emsp;&emsp;播放语音。</p>
<p>&emsp;&emsp;&emsp;&emsp;<em>channel</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;将要停止的通道，若此参数不存在将停止所有通道。<br>
&emsp;&emsp;&emsp;&emsp;<em>fadeout</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;淡出的时间，默认为0。<br></p>
<p>来给我们的游戏加上音乐吧。</p>
<pre><code>*main
[bgm file=&quot;sound/bgm/tam-n01&quot; loop=true]

[basic_dialogbox]
[sprite index=0 file=&quot;image/bg/bg441a_1280&quot;]
[addto index=0 target=basic_layer pos=[0,0] zorder=0 opacity=255]

[sprite index=1 file=&quot;image/character/A/2_happy&quot;]
[addto index=1 target=basic_layer zorder=10 pos=[400,120] opacity=255]
[sprite index=2 file=&quot;image/character/B/7_wordless&quot;]
[addto index=2 target=basic_layer zorder=10 pos=[640,120] opacity=255]

【凉子】[r]
抱歉，等很久了么？？[p]
【真由】[r]
啊，真是的，凉子你怎么那么慢？[p]

[stop channel=bgm] 
</code></pre>

<p>保存并编译运行，你可以听到现在游戏拥有背景音乐啦。</p>
<pre><code>BKE支持的音频格式有.mp3、.ogg与.wav。
</code></pre>

<h2 id='beginner-options'>选项</h2>
<p>在引用了 <code>extend.bkscr</code> 文件后，您可以使用 <code>select</code> 命令制作出一个选项。</p>
<p><code>select</code> 命令的格式如下：</p>
<p>&emsp;&emsp;<strong>select</strong> <em>file text label se</em><br>
&emsp;&emsp;&emsp;&emsp;创建一个选择菜单。</p>
<p>&emsp;&emsp;&emsp;&emsp;<em>file</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;用于选择项的背景图。<br>
&emsp;&emsp;&emsp;&emsp;<em>text<em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;用于显示的选择项文本，以数组形式传入。<br>
&emsp;&emsp;&emsp;&emsp;</em>label</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;对应文字跳转的标签，以数组形式传入。<br>
&emsp;&emsp;&emsp;&emsp;<em>se</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;选项按下时的音效，没有则不播放。<br></p>
<p>让我们来制作一个选择肢：</p>
<pre><code>*main
[bgm file=&quot;sound/bgm/tam-n01&quot; loop=true]

[basic_dialogbox]
[sprite index=0 file=&quot;image/bg/bg441a_1280&quot;]
[addto index=0 target=basic_layer pos=[0,0] zorder=0 opacity=255]

[sprite index=1 file=&quot;image/character/A/2_happy&quot;]
[addto index=1 target=basic_layer zorder=10 pos=[400,120] opacity=255]
[sprite index=2 file=&quot;image/character/B/7_wordless&quot;]
[addto index=2 target=basic_layer zorder=10 pos=[640,120] opacity=255]

【凉子】[r]
抱歉，等很久了么？？[p]
【真由】[r]
啊,真是的，凉子你怎么那么慢？[p]

[select file=&quot;image/menu/textwindow/2&quot; text=[&quot;要好好遵守约定啊&quot;,&quot;为什么会迟到呢&quot;] label=[&quot;*A&quot;,&quot;*B&quot;]]

*A
【真由】[r]
下一次可要好好遵守约定啊。[p]
[quit]

*B
【真由】[r]
平日里你不是很守时的吗？今天怎么迟到了？[p]
[quit]
</code></pre>

<p>保存并编译运行，您就可以看到，在之前的两句对话结束后，就产生了一个选项，不同的选择会让玩家跳转至不同的标签处。</p>
<p><img src="guide/images/7.jpg" img /></p>
<h2 id='beginner-jump'>跳转和if命令</h2>
<p>我们可以在上面的选项中加入一些判断，好让不同的选择通向不同的结局。这时候就需要掌握如何声明变量和根据变量的值来进行不同的操作。</p>
<p>在BKE中，声明变量必须以“#var”开头，后面书写变量的名称，行的最后以“;”号结束。（事实上，在BKE中，任何以“#”开头的行都必须以“;”号结束，详细原因会在以后的教程中介绍）</p>
<p>我们来定义一个变量，用它来记录人物的选择。</p>
<pre><code>*A
【真由】[r]
下一次可要好好遵守约定啊。[p]
#var ask=-1;
[jump label="*continue"]

*B
【真由】[r]
平日里你不是很守时的吗？今天怎么迟到了？[p]
#var ask=1;
[jump label="*continue"]

</code></pre>

<p>在不同的选择下，“ask”这个变量也会有不同的值。怎样用变量的值来控制剧情的走向呢？这时我们就需要用到 <code>if</code> 命令。</p>
<p><code>if</code> 命令的格式如下：</p>
<p>&emsp;&emsp;<strong>if</strong> <em>*exp</em><br>
&emsp;&emsp;&emsp;&emsp;根据表达式判断执行下面的语句，或跳转至else或elseif后面执行。</p>
<p>&emsp;&emsp;&emsp;&emsp;<em>exp</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;条件表达式。<br></p>
<p><code>elseif</code> 与 <code>if</code> 命令的格式相同：</p>
<p>&emsp;&emsp;<strong>elseif</strong> <em>*exp</em><br>
&emsp;&emsp;&emsp;&emsp;根据表达式判断执行下面的语句，或跳转至下一个else或elseif后面执行。</p>
<p>&emsp;&emsp;&emsp;&emsp;<em>exp</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;条件表达式。<br></p>
<p>当您使用了 <code>if</code> 命令进行条件判断时，您必须使用 <code>endif</code> 命令。它用于标志着 <code>if</code> 命令块的结束。</p>
<p>这里是一个完整的 <code>if</code> 命令块的例子：</p>
<pre><code>@if &quot;ask&gt;0&quot;
@jump label=&quot;*ask&quot;
@else
@jump label=&quot;*no_ask&quot;
@endif
</code></pre>

<p>它的意思是，在“ask”这个值大于0的情况下时，跳转到“ask”这个标签处，在其余情况下，则跳转到“no_ask”这个标签处。这里用到了控制跳转命令 <code>jump</code> 。</p>
<p>&emsp;&emsp;<strong>jump</strong> <em>*label file</em><br>
&emsp;&emsp;&emsp;&emsp;跳转到指定的标签处。</p>
<p>&emsp;&emsp;&emsp;&emsp;<em>label</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;将要跳转的标签。<br>
&emsp;&emsp;&emsp;&emsp;<em>file</em><br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;标签所在的文件。<br></p>
<p>把上面的代码整合进我们的游戏中，我们就可以按照玩家不同的选择来控制游戏的流程了。</p>
<pre><code>*main
[bgm file=&quot;sound/bgm/tam-n01&quot; loop=true]

[basic_dialogbox]
[sprite index=0 file=&quot;image/bg/bg441a_1280&quot;]
[addto index=0 target=basic_layer pos=[0,0] zorder=0 opacity=255]

[sprite index=1 file=&quot;image/character/A/2_happy&quot;]
[addto index=1 target=basic_layer zorder=10 pos=[400,120] opacity=255]
[sprite index=2 file=&quot;image/character/B/7_wordless&quot;]
[addto index=2 target=basic_layer zorder=10 pos=[640,120] opacity=255]

【凉子】[r]
抱歉，等很久了么？？[p]
【真由】[r]
啊,真是的，凉子你怎么那么慢？[p]


[select file=&quot;image/menu/textwindow/2&quot; text=[&quot;要好好遵守约定啊&quot;,&quot;为什么会迟到呢&quot;] label=[&quot;*A&quot;,&quot;*B&quot;]]

*A
【真由】[r]
下一次可要好好遵守约定啊。[p]
#var ask=-1;
[jump label="*continue"]

*B
【真由】[r]
平日里你不是很守时的吗？今天怎么迟到了？[p]
#var ask=1;
[jump label="*continue"]

*continue
@if &quot;ask&gt;0&quot;
@jump label=&quot;*ask&quot;
@else
@jump label=&quot;*no_ask&quot;
@endif
</code></pre>

<p>这个游戏还不完整，因为它还缺少必要的“ask”与“no_ask”这两个标签，以及这两个标签下对应的内容。但是在经历了上面的学习之后，相信您已经可以自己独立完成这个游戏的后半部分了。</p>
<p>利用手里面的素材,续写一下后面的故事吧！ :)</p>
<p>（如果您不想自己续写的话，请在后面下载完整版示例游戏查看效果）</p>
<!--Thanks to CountD TwT-->   

<h2 id='beginner-pub'>发布游戏</h2>
<p>恭喜您已经掌握了如何用BKE来制作属于自己的游戏！</p>
<p>在您完成了您自己的游戏后，您可以将它打包上传，并进行分享。</p>
<p>我们鼓励您使用BKE进行原创创作，凭借其强大的跨平台功能，您可以在任何平台上体验您自己的游戏，您会看见它们在不同的平台上都拥有完全相同的演出效果。</p>
<p><strong>我们非常乐意为您的原创游戏进行宣传，如果您使用BKE完成了自己的原创游戏，您可以<a href="&#109;&#x61;&#105;&#x6c;to&#x3a;&#x62;&#x61;&#107;&#x65;&#114;&#x69;&#115;&#116;&#46;&#x69;&#110;&#x66;&#x6f;&#64;&#x67;&#109;&#x61;&#x69;l&#46;&#99;&#x6f;&#x6d;">&#x81f4;&#20449;&#25105;&#x4eec;</a>，我们会将您的游戏放到我们的引擎展示页面，为您游戏的推广出一份力。</strong></p>
<h2 id='beginner-script'>示例游戏的完整脚本</h2>
<p>您可以在<a href="guide/resources/BKE_tutorial_script.zip">这里</a>下载到示例游戏的完整脚本。<br>
在运行它之前，请确认您已经下载了示例游戏的资源包，并将它们放在了同一目录下。</p>
<p>或者直接下载<a href="guide/resources/BKE_tutorial.zip">完整版的示例游戏</a>，将BKE引擎放置在游戏根目录内启动。</p>
<h2 id='beginner-next'>Go for the next！</h2>
<p>好了，新手教程就到此为止。现在应该干什么？</p>
<p>您可以：</p>
<ul>
<li>
<p>利用已经学到的知识，开始制作您自己的原创游戏。</p>
</li>
<li>
<p>访问我们的<a href="http://bke.bakery.moe">网站</a>来获取新的教程以及引擎的更新。</p>
</li>
<li>
<p>查看现有的<a href="guide/download/API_List.xlsx">API列表</a>，尝试制作更复杂的游戏。</p>
</li>
<li>
<p>加入我们的交流群，与其他人分享交流您的心得。<a target="_blank" href="http://shang.qq.com/wpa/qunwpa?idkey=dfa55730bc97ce7f8c2ab0943300560b67ec37d8c51c0b48d844fe0ca5d3d348"><img border="0" src="http://pub.idqqimg.com/wpa/images/group.png" alt="BKEngine支援群" title="BKEngine支援群"></a></p>
</li>

</ul>
<p>考虑到难度原因，在这篇新手教程里我们省略掉了许多复杂的东西，我们会在之后的教程中详细介绍它们的功能及用法。为了更详细的了解 BKE ，我们建议您继续阅读接下来的教程，让我们来向您展示这些功能。</p>
<p>如果您对BKE有不了解的地方，您可以在我们的<a href="http://bbs.bakery.moe/">官方论坛</a>发帖询问，我们会热情的对待每一个初学者。</p>
<p>感谢您选择了 BKEngine。我们期待着您的大作！</p>
</section><h1 id='grammar'>语法及变量简介</h1>
<hr />
<p>在之前的新手教学中，我们简单地介绍了BKEngine的一些基础功能。<br>
在本章教程中，我们将为您介绍BKE的基本语法规则以及基本的变量类型，为以后的学习做好铺垫。
<br></p>
<h2 id='grammar-script'>脚本文件</h2>
<p>BKEngine的脚本文件包括了游戏根目录下所有的 <code>.bkscr</code> 文件。BKEngine会自动按照unicode顺序搜索所有以 <code>.bkscr</code> 后缀名结尾的脚本文件进行编译，并读取编译后的二进制文件执行游戏。</p>
<p>通常来说，组成一个BKE游戏的最小脚本是两个， <code>main.bkscr</code> 与 <code>macro.bkscr</code> (以 <code>.bkpsr</code> 结尾的是配置文件，不考虑在脚本文件范围中)。其余的都是用户自行增加的脚本。事实上，把脚本文件分成很多个是没有意义的，您可以通过指定跳转到某个文件中的标签，但它与在本文件中跳转并无二致。不过使用多个剧本通常易于进行游戏路线的梳理与模块的管理，所以具体怎么划分脚本其实是无所谓的，有些人喜欢一个大文件，而有些人则喜欢很多零碎的小文件，这完全取决于您自己的喜好。</p>
<p>为了加速启动以及保护脚本，BKE Creator带有能将 <code>.bkscr</code> 编译成二进制的 <code>.bkbin</code> 文件的编译器。而BKEngine则是通过读取 <code>.bkbin</code> 文件启动的，所以在您对您的游戏进行更改之后，请在BKE Creator中执行编译选项，更新您的 <code>.bkbin</code> 文件，从而确保您的游戏是最新的版本。</p>
<p>编译器会自动搜索根目录与 <code>config.bkpsr</code> 中设置的放置的脚本文件夹中的脚本进行编译。如果您不想将脚本全放在根目录下的话，您可以通过BKE Creator配置 <code>config.bkpsr</code> 中的预设脚本搜索文件夹，来更改编译器的脚本搜索路径。</p>
<h2 id='grammar-variable'>基础变量</h2>
<p>变量可视为在内存里可修改的、存在值的命名空间。<br>
当某个已宣告变量开始使用，引擎会设定一个空间来储存所给出的值。稍后该变量不再使用时，那些空间将会回收。
变量可以用来存储诸如游戏的好感度、人物的HP、游戏进行的路线等。<br>
在BKE中，声明变量时的写法如下：</p>
<pre><code>#var 变量名;
</code></pre>

<p>这样所声明的变量作用域为当前闭包（“{}”内），若是在所有作用域之外直接使用 <code>var</code> 声明变量，那么该变量会成为全局变量。</p>
<p>在声明变量的同时，可以通过等号对其赋值：</p>
<pre><code>#var 变量名=值;
</code></pre>

<h3>变量的命名</h3>
<p>在BKE中,变量名由下划线或大小写英文字符或中文字符开头，由下划线或字符或中文字符或数字组成，如：</p>
<pre><code>#var a2;
#var _aa;
#var 中文变量;
</code></pre>

<p>但是您不能将变量命名为BKE内已经存在的保留字。例如：</p>
<pre><code>#var while;      //错误，变量名是已经存在的关键字
#var whileinit;   //正确，虽然包含关键字，但是并非关键字，所以该句正确
</code></pre>

<p>下面是BKE的保留字清单：</p>
<pre><code>      for   foreach  in  extends  do  return  global  
      while  function  propset  propget  int  this
      string  number  typeof  var  delete  true  void
      class  if  else  continue  break  false           
</code></pre>
<h3>变量的类型</h3>
<p>对于BKE来说，与C/C++不同，您无需声明变量的类型，变量将自动被更改为赋值对象的类型，同时，在计算过程中，某些变量会自动根据上下文来改变自己的类型（仅限 <code>void</code> ， <code>number</code> ， <code>string</code> 之间）。</p>
<p>虽然BKE的变量无需声明“类型”，但在系统内部变量实际上是拥有类型的。在BKE内的内部类型如下：</p>
<h4>void(空)</h4>
<p><code>void</code> 表示空变量，当访问字典或数据里不存在的变量时会得到这个值。</p>
<h4>number(数值)</h4>
<p>表示一个整数或一个浮点数(小数)。<br>
  整数格式：<br>
&emsp;&emsp;［0｜0x｜0X］+数字或十六进制字母(在以 <code>0x</code> 开头时)。</p>
<p>当数字以 <code>0x</code> 或 <code>0X</code> 开头时，后面的序列会被当成十六进制的数，其余情况被当成是十进制。如:</p>
<pre><code>   0xA=10  //这是十六进制
   0xc=12  //这也是十六进制
   233=233 //十进制
</code></pre>

<p>浮点数格式:<br>
&emsp;&emsp;［数字｜小数点+数字］+［e｜E+［加号或减号］+数字］，同时也支持上述的整数格式。</p>
<p>在这种表示方法中， <code>E</code> 或者 <code>e</code> 代表的是指数，表示将前面的数字乘以 10 的 n 次幂，n 是 <code>E</code> 或者 <code>e</code> 之后的数字（带符号）。<br>
当以数字加  <code>.</code> （小数点）开头时，此时变量会被当成十进制，以 <code>0x</code> 或 <code>0X</code> 开头时，会被当成十六进制（在非十进制的情况下， 用 p 来表示以 2 为底的指数)。如:</p>
<pre><code>   2.33e2=233   //即2.33x10^2
   23E-3=0.023  //即23x10^-3
   0.5=0.5      //十进制小数
   0x2.3ep10=2297    //即0x2.3e*2^10，等于2297
</code></pre>

<h4>string(字符串)</h4>
<p>一个不定长度，不可变的unicode字符串。由两个单引号或者双引号包围起来。例如：</p>
<pre><code>   &quot;这是一个字符串&quot;
   &quot;This is a string&quot;
</code></pre>

<p>在字符串中 \ (反斜杠) 具有特殊的意义。跟在 \ 的字符的意义会改变。跟在 \ 后面的这种特殊的指定方式被称为转义(escape) 。</p>
<p>BKE的字符串默认不支持转义字符，在由一头一尾两个双引号括起来的字符串中，连起来的双引号会被当成字符串内的一个双引号而不是字符串结束符号。在以单引号括起来时，字符串支持转义字符。</p>
<p>要支持\n，\r，\t和 \ &quot; 这些转义字符，需要使用单引号将字符串括起来。比如：</p>
<pre><code>   &quot;abc&quot;            //包含abc三个字母的字符串。
   &quot;abc&quot;&quot;abc&quot;       //以一个双引号隔开的两个abc。
   &quot;abc'abc&quot;        //以一个单引号隔开的两个abc。
   '\r\n'           //windows下的回车换行符。
   'what\'s this'   //这里使用了 \' 来转义书写单引号 
</code></pre>

<p>在BKE内部把所有字符用unicode格式来处理，全角字符按 1 个字符来计数，半角字符也是按 1 个字符来计数。</p>
<h4>array(数组)</h4>
<p>由一组变量(任意类型)组成的类型，可以嵌套。可以通过数字下标来引用元素(负下标表示从后往前数)。需要用中括号括起来，元素间由逗号隔开。<br>
在声明数组时，并不需要对数组的大小做出定义。BKE将会自动扩展数组大小到用户所使用的大小，并将没有被赋值的元素初始化为 <code>void</code>  。</p>
<p>对于数组，我们可以通过其下标来对其中的元素进行索引。下标为整数，0表示数组中的第一个元素，1表示第二个对象，依此类推。如果指定负数作为索引，则将被当作从数组的结束位置开始指定元素，-1 表示最后的元素。</p>
<p>下面是声明一个数组的例子：</p>
<pre><code>#var count=[];                   //声明一个空数组count
#var sum=[&quot;chara&quot;,100,[50,55]]   //声明一个有默认元素的数组sum
</code></pre>

<p>这是引用数组内元素的例子：</p>
<pre><code>sum[0]    //sum[0]即数组sum的第一个元素，字符串&quot;chara&quot;
sum[1]    //sum[1]即数组sum的第二个元素，数字100
sum[-1]   //sum[-1]即数组sum的最后一个元素，数组[50,55]
sum[-2]   //sum[-2]即数组sum的倒数第二个元素，数字100
sum[2][1] //sum[2]即数组sum的最后一个元素，数组[50,55]，同时第二个中括号内的是sum数组内这个数组的下标，即sum数组内数组的第二个元素，数字55
sum[3]    //数组的第四个元素，未定义，BKE将会自动扩展数组sum至四个大小，同时将sum[3]赋值为 void 
</code></pre>

<h4>dictionary(字典)</h4>
<p>由一些键-值对组成的变量，键为字符串型，值可以是任意类型的变量，可以嵌套。可以通过字符串下标来引用元素。字典由  <code>%[</code>  开头， <code>]</code> 结尾，键-值对之间用逗号隔开，键和值之间用冒号隔开。若值被省略，则BKE将会报错。<br>
BKE中的字典类型没有顺序，系统会自动按照Hash顺序来排序。</p>
<p>对于字典的声明并赋值，有两种写法：</p>
<pre><code>#var book=%[page:100,price:10,name:&quot;dict&quot;];
#var book=%[&quot;page&quot;=&gt;100,&quot;price&quot;=&gt;10,&quot;name&quot;=&gt;&quot;dict&quot;];
</code></pre>

<p>以上两种写法都是可以的。后者的写法更类似于 Perl 。但是请您注意，后者的写法中，键的名称被双引号括了起来，而在前者的写法中，键的名称则不用加双引号。在使用后者写法的场合，请注意一定要在键的名称上加上双引号，否则系统将会报错。</p>
<p>对于字典的值的引用，也有两种写法：</p>
<pre><code>book.price  //返回的值为10
book[&quot;price&quot;]   //返回的值为10
</code></pre>

<p><code>.</code>  运算符在BKE Parser中起着直接成员选择的作用，所以上面两种写法是等价的，后者的写法对于使用 Python 或 Perl 的用户来说可能会更亲切一些。</p>
<h3>常量</h3>
<p>在BKE中，有两个关键字： <code>true</code> 和 <code>false</code> ，它们分别代表逻辑值真与逻辑值假。它们的值为1与0。</p>
<h3>变量的自动转换</h3>
<p>根据运算的需要，变量的类型有时候会被自动转换，但仅限于 <code>void</code> ， <code>number</code> 和 <code>string</code> 之间。 <code>void</code> 会被转成0或者空字符串。</p>
<p>您也可以使用 <code>number(变量名)</code> 和 <code>string(变量名)</code> 这两个命令进行强制转换（这样的强制转换不会影响原变量）。当数字转字符串时，只会显示六位，超过时会使用科学表示法或舍去小数点后更多的位数。字符串转数字会直到不合法的字符的时候停止。下面是例子：</p>
<pre><code>  #string(100000)=&quot;100000&quot;
  #string(1000000)=&quot;1e+006&quot;
  #string(1.2345678)=&quot;1.23457&quot;
  #string(0.000233)=&quot;0.000233&quot;
  #string(0.0000233)=&quot;2.33e-005&quot;
  #number(&quot;0x0a&quot;)=10
</code></pre>

<p>其余的转换（如number到array）都是非法的。</p>
<h2 id='grammar-cmd'>BKE命令的组成与语法</h2>
<h3>命令的组成</h3>
<p>在BKE中，解释器会逐行解释脚本文件中的内容。BKE会根据关键字来判断当前的文字是命令、文本或是注释。</p>
<p>对于任何以 “//” （两个半角斜杠）开始，该行在 “//” 之后的文本都会被视为注释。BKE会无视所有注释，即使注释后面拥有命令关键字。</p>
<p>而对于命令来说，它们由一些非常基本的部分组成:</p>
<p><strong><em>关键字</em></strong><br>
&emsp;&emsp;关键字是必须出现在脚本里的词语。它们用来声明接下来的部分是一个BKE命令。通常使用半角的 <strong><code>@</code></strong> 符号或是半角的 <strong><code>[</code></strong> 。对于 <strong><code>@</code></strong> 符号标记的命令而言，它只能出现在一行的行首位置，前面不能有任何东西。而以 <strong><code>[</code></strong> 符号标记的命令则可以出现在除注释外的任何位置。对于脚本标签，则使用 <strong><code>*</code></strong> 符号进行标记。</p>
<p><strong><em>命令名</em></strong><br>
&emsp;&emsp;用于表明接下来的命令的名称，让BKE知道它应该接受哪些参数，起到什么样的作用。</p>
<p><strong><em>参数名</em></strong><br>
&emsp;&emsp;参数名用来让BKE知道接下来传给引擎的是什么参数。参数名可以按照任意的顺序写出，只要任何参数名只出现一次。参数名与参数名之间使用空格分割。</p>
<p><strong><em>参数值</em></strong><br>
&emsp;&emsp;对应参数名的值。值与参数名之间使用 <code>=</code> 号分割。</p>
<p>下面是两个完整的命令，你可以看到它们拥有上面的所有属性：</p>
<pre><code>@sprite index=1 file=&quot;image/character/A/1_normal&quot;
[sprite index=0 file=&quot;image/bg/BG25a_1280&quot;]
</code></pre>

<p>除了命令与注释之外的文字，都会被当做文本显示出来。</p>
<p>不过还有两个例外，就是以 “#” 开头的用于声明变量的命令，以及以 “##” 开头，以 “##” 结尾（中间可以跨行）的语句块，在其中的所有语句都会被传给BKE的语法分析器（BKE Parser）来执行。</p>
<p>下面的例子就包含了所有可能在BKE中出现的文字：</p>
<pre><code>*main
@bgm file=&quot;sound/bgm/bgm_1&quot; loop=true
@basic_dialogbox
@sprite index=0 file=&quot;image/bg/bg_1&quot;
@addto index=0 target=basic_layer pos=[0,0] zorder=0 opacity=255

这就是——[l][r]
属于我们的，美好的每一天。[p]

#var ending=1;
</code></pre>

<h3>语法</h3>
<p>对于BKE命令来说，需要注意的问题不多，大部分BKE命令使用同一套语法，它们都由它们都由关键字开始，关键字后面是命令名，而后是参数名和参数（如果这个命令接受参数的话）。</p>
<p>其实BKE的语法并没有太多复杂之处，真正拥有高度扩展性的是BKE Parser，我们会在以后的教程中详细介绍它，而它才是BKE强大之处的体现。</p>
<h2 id='grammar-next'>Go for the next！</h2>
<p>事实上，目录里面并没有这一节，不过我还是想把它当成一个小剧场一样的东西继续下去:D</p>
<p>在学习了本章的内容之后，结合前面的东西，相信您已经可以很好的掌握BKE的语法了，但先别急着高兴，这其实只是冰山的一角=w=</p>
<p>感谢您阅读本章的教程，希望在后面的教程也能遇见您～</p><h1 id='image'>图像显示</h1>
<hr />
<p>在本章的教程中，我们将详细地介绍BKE的图像显示部分。
<br></p>
<h2 id='image-sprite'>精灵</h2>
<p>精灵是所有显示图像的基础形式，无论是背景还是人物，或是界面上的按钮，这些都是精灵。精灵有着广泛的用途：</p>
<blockquote>
<ul>
<li>使用addto命令将其添加至某个层或精灵上</li>
<li>通过使用buttonex命令，来创建一个按钮</li>
<li>通过使用sliderex命令，来创建一个滑条</li>
<li>使用精灵来创建一个动画</li>
</ul>
</blockquote>
<p>在使用精灵之前，我们需要声明一个精灵，声明精灵的命令虽然在之前的新手教学里面已经提过了，不过我们还是重复一下：</p>
<p>&emsp;&emsp;<strong>sprite</strong> <em>*index *file rect</em><br>
&emsp;&emsp;创建一个精灵。</p>
<p>&emsp;&emsp;<em>index</em><br>
&emsp;&emsp;&emsp;&emsp;将要创建精灵的编号。<br>
&emsp;&emsp;<em>file<em><br>
&emsp;&emsp;&emsp;&emsp;用于创建精灵的图片文件。<br>
&emsp;&emsp;</em>rect</em><br>
&emsp;&emsp;&emsp;&emsp;截取的图片范围。<br></p>
<p>在声明之后，精灵将会被载入到内存中。在需要复杂的演出效果时（屏幕上一次性显示大量的精灵），您可以预先载入一些精灵到内存中，避免在某一时刻突然载入大量的精灵，这样有可能会使游戏的帧数惨不忍睹，降低玩家的游戏体验。<br>
在不需要改变图像的尺寸时，图像的属性就是固定的，并且不随着游戏状态等外部因素的改变而改变，所以您可以预载图像，让其存放在图像缓存中，从而能在需要时迅速调用。</p>
<p>BKE支持PNG、JPG、BMP等常用图像格式，在声明精灵时，您可以不填写图像的后缀名，让BKE自行搜索符合文件名的图像文件，如果存在不同后缀名的同名文件，BKE的搜索顺序是PNG&gt;JPG&gt;BMP。</p>
<p>但仅仅只是声明的话，精灵是不会显示在屏幕上的，我们需要自己将它添加到某个精灵/层上去，这时候就需要用到 <code>addto</code> 命令了。但在将精灵添加到屏幕上之前，我们还需要先了解一下 <code>addto</code> 所作用的对象——层的含义。</p>
<h2 id='image-layer'>层和addto</h2>
<p>在BKE中，预定义了两个层（layer），它们分别是BasicLayer和MessageLayer。前者是基础层，后者则是用于显示文字消息的层，它们的默认属性如下：</p>
<p>    <strong>basic_layer</strong> <em>index=-1 zorder=0</em><br>
    <strong>message_layer</strong> <em>index=-2 zorder=50</em></p>
<p>从默认属性看来，层似乎和精灵有着很多的相同点：它们都有着编号（index）和深度值（zorder），都可以作为 <code>addto</code> 命令的目标对象……等等。事实上，在BKE的原生class中，并没有“层”这一定义，只是当我们向一个精灵上加上了别的精灵时，对于有形的图片，我们就将其称为“父精灵”；而对于无形的精灵——例如basic_layer这种看不到实体的来说，我们就将其称为“层”了。</p>
<pre><code>在以后的教学中，对于附加有精灵的有形图片，我们统称为“父精灵”，而对于无形的单位来说，则统称为“层”。
</code></pre>

<p>我们之前使用了 <code>addto</code> 命令将精灵添加到了BasicLayer这个层上，虽然也是老生常谈，不过我们还是来重温下 <code>addto</code> 命令的用法：</p>
<p>&emsp;&emsp;<strong>addto</strong> <em>*index *target zorder pos opacity</em><br>
&emsp;&emsp;添加一个精灵（源精灵）到另一个层或精灵（目标精灵）上。</p>
<p>&emsp;&emsp;<em>index</em><br>
&emsp;&emsp;&emsp;&emsp;源精灵的编号。<br>
&emsp;&emsp;<em>target<em><br>
&emsp;&emsp;&emsp;&emsp;目标精灵/层的编号/名称<br>
&emsp;&emsp;</em>zorder</em><br>
&emsp;&emsp;&emsp;&emsp;精灵的深度，默认为0。<br>
&emsp;&emsp;<em>pos</em><br>
&emsp;&emsp;&emsp;&emsp;叠加的坐标，默认为[0,0]。<br>
&emsp;&emsp;<em>opacity</em><br>
&emsp;&emsp;&emsp;&emsp;精灵的不透明度，默认为255。<br></p>
<p>我们在新手教学里已经有过例子，之前我们将所有图片的目标层全部设置为了BasicLayer，不知道您对之前我们所提到的为什么要将目标层设置为BasicLayer是否还有印象？</p>
<blockquote>
<p>对于初学者而言，我们建议您将所有的目标层都设置为 basic_layer ，这样的话，所有的坐标都是相对于左上角原点0,0来计算的。</p>
</blockquote>
<p>这是因为 <code>addto</code> 里面的 <code>pos</code> 属性的座标全部是相对于目标左上角座标来进行计算的。而BasicLayer的左上角座标就是[0,0]，所以您可以将BasicLayer的原点座标视为屏幕的左上角座标（因为它们都是一样的）。</p>
<p>当我们有许多精灵要同时变形、或是相对于原点的座标计算比较麻烦时，我们可以创建一个层，将精灵添加至其上。创建layer的命令如下：</p>
<p>&emsp;&emsp;<strong>layer</strong> <em>*index *width *height color opacity</em><br>
&emsp;&emsp;创建一个指定大小的层或颜色精灵，这里的透明度是这个精灵／层本身的透明度。</p>
<p>&emsp;&emsp;<em>index</em><br>
&emsp;&emsp;&emsp;&emsp;创建的编号。<br>
&emsp;&emsp;<em>width<em><br>
&emsp;&emsp;&emsp;&emsp;创建的层／颜色精灵的宽度。<br>
&emsp;&emsp;</em>height</em><br>
&emsp;&emsp;&emsp;&emsp;创建的层／颜色精灵的高度。<br>
&emsp;&emsp;<em>color</em><br>
&emsp;&emsp;&emsp;&emsp;层的颜色，默认为白色（即0xFFFFFF）。<br>
&emsp;&emsp;<em>opacity</em><br>
&emsp;&emsp;&emsp;&emsp;层的不透明度，默认为0（即完全透明）。<br></p>
<p>这个命令在指定颜色时，创建的会是一个固定大小的色块，也就是纯色的精灵，在不指定颜色或是不透明度为0时，我们就认为它所创建的是一个层。</p>
<p>在了解了关于层的定义之后，我们可以使用 <code>addto</code> 命令将已经声明的精灵添加到目标精灵／层上。请注意，声明和添加精灵并不一定要一起进行，您可以预先就声明好精灵，然后在合适的时间再将其添加到目标对象上。</p>
<p>在下面的示例中，创建了一个新的图层，并将人物立绘添加至其上显示，例子的素材可以在之前的新手教学中下载到。</p>
<pre><code>*main

[sprite index=0 file=&quot;image/bg/BG25a_1280&quot;]
[addto index=0 target=basic_layer pos=[0,0] zorder=0 opacity=255]

[layer index=10 width=1280 height=720 opacity=0]
[addto index=10 target=basic_layer pos=[640,120] zorder=50]
//创建了一个编号为10的层，其座标为640,120。

[sprite index=1 file=&quot;image/character/A/1_normal&quot;]
[addto index=1 target=10 zorder=10 pos=[-220,0] opacity=255]
[sprite index=2 file=&quot;image/character/B/1_normal&quot;]
[addto index=2 target=10 zorder=10 pos=[40,0] opacity=255]
//将两个人物立绘添加到了层上，座标是相对于层的原点计算的
[wait time=5000 canskip=false]
[addto index=10 target=basic_layer pos=[440,120] zorder=50]
//改变了层的座标，附加在层上的人物位置也随之改变了
</code></pre>

<p>可以看到，人物立绘的座标都是按照其目标层来计算的，在立绘图像被添加到层上之后，一旦层产生了移动，那么其上的人物立绘也会随之移动。<br>
我们可以使用层来做许多效果，比如说当我们需要同时移动许多精灵时，不是一个个地来进行移动操作，而是将其添加到层上之后，对层进行移动变化，这样可以使工作简单许多。</p>
<h2 id='image-remove'>移除精灵</h2>
<p>有添加精灵的场合，当然就有移除精灵的场合。在从某个界面跳转到另一个界面时，我们就必须卸载掉之前所添加的精灵，否则这些没用到的精灵就会占据我们的内存。对于某些频繁使用到的图片，我们可以使用 <code>addto</code> 命令改变其透明度，再在合适的时候重新显示，但对于不频繁使用的图片，我们建议您还是移除掉它。</p>
<p>移除命令有两个，一个是 <code>remove</code> ：</p>
<p>&emsp;&emsp;<strong>remove</strong> <em>*index delete</em><br>
&emsp;&emsp;从一个精灵的父精灵/层上取下自己，该精灵变为不可见。</p>
<p>&emsp;&emsp;<em>index</em><br>
&emsp;&emsp;&emsp;&emsp;欲移除的精灵的编号。<br>
&emsp;&emsp;<em>delete</em><br>
&emsp;&emsp;&emsp;&emsp;是否销毁精灵，默认为false。<br></p>
<p>另一个是 <code>removeall</code> ：</p>
<p>&emsp;&emsp;<strong>removeall</strong> <em>*index delete</em><br>
&emsp;&emsp;从一个精灵／层上取下所有子精灵，所有子精灵变为不可见。</p>
<p>&emsp;&emsp;<em>index</em><br>
&emsp;&emsp;&emsp;&emsp;欲移除所有子精灵的精灵／层的编号。<br>
&emsp;&emsp;<em>delete</em><br>
&emsp;&emsp;&emsp;&emsp;是否销毁精灵，默认为false。<br></p>
<p>可以看到，这两个移除命令，一个是针对子精灵而言，另一个则是针对父精灵／层而言。但是要注意的是，在使用 <code>removeall</code> 移除了父精灵／层上的所有精灵后，父精灵／层本身却不会消失。它们的适用场合不同，所以请不要混用。</p>
<p>在两个命令之中，都有一个 <code>delete</code> 参数。 <code>delete</code> 参数的意义是，如果在移除精灵但却未销毁精灵的情况下（即 <code>delete=false</code> ），精灵原有的所有可选参数都会被保留下来，下一个使用这个编号的精灵会继承之前精灵的所有可选参数；但如果销毁了精灵（即 <code>delete=true</code> ），那么精灵原有的参数全部会被销毁，新的精灵在不指定可选参数的情况下，会自动使用默认参数。</p>
<p>下面是一个关于 <code>remove</code> 和 <code>removeall</code> 的例子，里面同时也有关于 <code>delete</code> 参数的演示：</p>
<pre><code>*main

[sprite index=0 file=&quot;image/bg/BG25a_1280&quot;]
[addto index=0 target=basic_layer pos=[0,0] zorder=0 opacity=255]
[layer index=10 width=1280 height=720 opacity=0]
[addto index=10 target=basic_layer pos=[640,120] zorder=50]
[sprite index=1 file=&quot;image/character/A/1_normal&quot;]
[addto index=1 target=10 zorder=10 pos=[-220,0] opacity=255]
[sprite index=2 file=&quot;image/character/B/1_normal&quot;]
[addto index=2 target=10 zorder=10 pos=[40,0] opacity=255]
[wait time=5000 canskip=false]

[remove index=1 delete=false]
//这里移除了精灵，但是没有销毁
[wait time=2000 canskip=false]
[sprite index=1 file=&quot;image/character/A/2_happy&quot;]
[addto index=1 target=10]
//重新添加的精灵继承了之前精灵的参数
[wait time=2000 canskip=false]
[remove index=1 delete=true]
//这里移除了精灵并销毁了它
[sprite index=1 file=&quot;image/character/A/2_happy&quot;]
[addto index=1 target=10]
//重新添加的精灵使用了默认参数，即pos=[0,0] opacity=233
[wait time=2000 canskip=false]
[removeall index=10 delete=true]
//请注意，这里的目标是层，移除了所有子精灵
</code></pre>

<h2 id='image-info'>图像的信息</h2>
<p>有些时候我们需要在游戏内获取一个图像的信息，以对图像进行变换。这时我们就需要使用 <code>info</code> 与 <code>infoex</code> 命令来获取图像文件的信息。</p>
<p>&emsp;&emsp;<strong>info</strong> <em>*file *get</em><br>
&emsp;&emsp;获取一个图片的信息，获取一个字典保存至get字符串对应的变量。字典成员有filename、width、height。</p>
<p>&emsp;&emsp;<em>file</em><br>
&emsp;&emsp;&emsp;&emsp;待获取的图片的文件名。<br>
&emsp;&emsp;<em>get</em><br>
&emsp;&emsp;&emsp;&emsp;信息将要保存到的变量。<br></p>
<p>&emsp;&emsp;<strong>infoex</strong> <em>*file *get</em><br>
&emsp;&emsp;获取一个精灵的信息，获取一个字典保存至get字符串对应的变量。字典成员有filename、width、height、type、pos、index、parent、children。</p>
<p>&emsp;&emsp;<em>file</em><br>
&emsp;&emsp;&emsp;&emsp;待获取的精灵的编号。<br>
&emsp;&emsp;<em>get</em><br>
&emsp;&emsp;&emsp;&emsp;信息将要保存到的变量。<br></p>
<p>从命令简介不难看出，info与infoex的区别在于，前者是从文件直接获取信息，后者则是从精灵上获取信息，所以后者的返回值会比较多一些。<br>
在后者的返回字典中,出了文件名以及图片的宽度、高度之外，还有精灵的类型、位置、索引、父精灵、子精灵。</p>
<p>在获得返回的字典之后，您可以直接通过字典的键来引用相对应的值。</p>
<pre><code>[info file=&quot;character/A/1&quot; get=picinfo]
#var display_pos=[400-picinfo[&quot;width&quot;]/2,120];
</code></pre>

<p>在例子中获取了一张图片的宽度，并将其除以二之后赋值给了另一个数组。您也可以写成下面这样：</p>
<pre><code>[info file=&quot;character/A/1&quot; get=picinfo]
#var display_pos=[400-picinfo.width/2,120];
</code></pre>

<p>两者并无任何功能上的区别，这只是字典的两种不同引用值的形式而已。</p>
<p>在合理使用 <code>info</code> 与 <code>infoex</code> 命令的情况下，我们可以进行一些游戏内的运算，来使图像显示出我们所预期的效果，并且减少许多事前计算。</p>
<h2 id='image-anchor'>锚点</h2>
<p>想必您应该知道数学中的平面直角座标系，比如这个：</p>
<p><center><img src="guide/images/3-0.jpg" /></center></p>
<p>它的两条数轴，X轴与Y轴，分别置于水平位置与铅直位置；取向右与向上的方向分别为X轴和Y轴的正方向，原点O的位置即是X轴与Y轴的公共点(0,0)。</p>
<p>BKE中的座标系统也与之类似。唯一不同的是，在BKE座标系统中，Y轴是取向下方向为正方向的，即由上到下递增。如下图示意：</p>
<p><center><img src="guide/images/3-1.jpg" /></center></p>
<p>图片的座标计算也相同。假设我们有一张300x450大小的图片，那么它的座标是这样的：</p>
<p><center><img src="guide/images/3-2.jpg" /></center></p>
<p>在了解了二者的座标系统之后，我们可以来看看将图片放置到屏幕上的过程，比如我们现在将这张图片放到屏幕的(200,150)处：</p>
<p><center><img src="guide/images/3-3.jpg" /></center></p>
<p>由上图可以看到，图片的原点(0,0)自动锚定在了(200,150)这个点上。</p>
<p>这样我们就成功的添加了一张图片到屏幕上了，可喜可贺——不过也许您会问，如果我想将图片显示在屏幕的中心位置时应该怎么办？</p>
<p>或许有些人会这么回答：那就将图片放到屏幕的中心位置不就好了？</p>
<p><center><img src="guide/images/3-4.jpg" /></center></p>
<p>显而易见，简单地直接将图片放置在屏幕的中心点是不能让图片居中显示的，我们需要计算一下对应这个图片大小的屏幕中心点，这个很简单，相信您也已经计算出来了：</p>
<p><center><img src="guide/images/3-8.jpg" /></center></p>
<p>不过，每一次显示图片的时候都需要去计算图片的显示位置，未免太过于繁复了些。在没有太多显示图片的情况下还好，但如果是在有很多图片需要显示的场合，一张一张地去计算显示位置的座标就太反人类了。为了解决这个问题，我们就需要用到锚点（anchor）。</p>
<p>所谓的“锚点”，其实就是图片的座标系统中的某个点。当图片需要定位时，我们就可以用这个点来表达图片的显示位置。<br>
默认情况下，图片的锚点是左上角的原点(0,0)处。
在之前的演示中是这么表述的：“图片的原点(0,0)自动锚定在了(200,150)这个点上”——事实上，这时图片的锚点就是(0,0)这个点。当我们给图片指定一个座标时,图片的锚点就会与我们给定的座标点重合。</p>
<p><center><img src="guide/images/3-5.jpg" /></center></p>
<p>但归根结底，以图片的(0,0)处作为锚点只是BKE的默认情况，我们可以自己更改图片的锚点位置。</p>
<p>这时候我们就需要用到设置锚点的命令—— <code>anchor</code> 。</p>
<p>&emsp;&emsp;<strong>anchor</strong> <em>*index set keep</em><br>
&emsp;&emsp;调整一个精灵/层的锚点。</p>
<p>&emsp;&emsp;<em>index</em><br>
&emsp;&emsp;&emsp;&emsp;将要调整锚点的精灵的编号。<br>
&emsp;&emsp;<em>get</em> <br>
&emsp;&emsp;&emsp;&emsp;获取锚点的坐标。<br>
&emsp;&emsp;<em>set</em><br>
&emsp;&emsp;&emsp;&emsp;设置锚点。<br>
&emsp;&emsp;<em>keep</em><br>
&emsp;&emsp;&emsp;&emsp;是否保持精灵不动（将根据锚点的变化相应改变坐标，仅此一次有效），默认为false。</p>
<p>对于 <code>set</code> 这个参数而言，它拥有9个预设位置，它们分别是：<br>
&quot;center&quot;（中央）,&quot;topleft&quot;（左上）,&quot;leftcenter&quot;（左中），&quot;bottomleft&quot;（左下），&quot;bottomcenter&quot;（下中），&quot;bottomright&quot;（右下），&quot;rightcenter&quot;（右中），&quot;topright&quot;（右上），&quot;topcenter&quot;（上中）。</p>
<p>当您指定某个预设位置为锚点时，BKE会自动根据图片的大小来计算这个点相对应的图片座标中的点。但需要注意的是，当您使用 <code>set</code> 这个参数设置了锚点后，就不能再使用 <code>get</code> 参数获取锚点的坐标了，否则BKE将会报错。</p>
<p>这个命令的最后一个参数keep，是一个布尔值——即只能为 <code>true</code> 或 <code>false</code> 。当它的值为 <code>true</code> 时，图片的锚点会设置为新的某个点，但图片的位置将不会发生变动；当它的值为 <code>false</code> 时，图片的锚点会设置为新的某个点，并且BKE会移动图片，使它的新锚点与之前给定的座标点重合。</p>
<p>现在让我们将之前那张图片的锚点设定在它的中心位置：</p>
<pre><code>[anchor index=10 set=&quot;center&quot; keep=true]
</code></pre>

<p>或者</p>
<pre><code>[anchor index=10 set=[150,225] keep=true]
</code></pre>

<p>现在图片的锚点就被设置在中心位置了：</p>
<p><center><img src="guide/images/3-6.jpg" /></center></p>
<p>现在我们就可以将图片直接放置在屏幕的中心位置，而不用计算那些繁复的座标了。</p>
<p><center><img src="guide/images/3-7.jpg" /></center>‘</p>
<h2 id='image-zorder'>深度</h2>
<p>在BKE中，影响图片叠加层次的是深度值（zorder）。</p>
<p>对于处于同一层级的精灵来说， <code>zorder</code> 的值越大，精灵的显示位置就越靠前；对于不同层级的精灵来说，如果A精灵所在层级的 <code>zorder</code> 要低于B精灵所在的层级，那么无论怎样增加A精灵的 <code>zorder</code> 值，A精灵都不可能显示在B精灵之前；对于同层级同 <code>zorder</code> 的精灵来说，后添加者在上。</p>
<p>某个精灵的 <code>zorder</code> 值可以通过两个方式来更改，第一种是在添加精灵时设置它的 <code>zorder</code> 值，第二种则是使用 <code>zorder</code> 命令来修改：</p>
<p>&emsp;&emsp;<strong>zorder</strong> <em>*index set get</em><br>
&emsp;&emsp;调整/获取一个精灵的 zorder 值。</p>
<p>&emsp;&emsp;<em>index</em><br>
&emsp;&emsp;&emsp;&emsp;将要调整 zorder 值的精灵的编号。<br>
&emsp;&emsp;<em>set<em><br>
&emsp;&emsp;&emsp;&emsp;设置的 zorder 值。<br>
&emsp;&emsp;</em>get</em><br>
&emsp;&emsp;&emsp;&emsp;获取的 zorder 值将要保存到的变量。<br></p>
<p>通过 <code>zorder</code> 命令，我们不仅可以设置某个精灵的 <code>zorder</code> 值，还可以获取某些精灵的 <code>zorder</code> 值，以便于在BKE内部实时计算空闲 <code>zorder</code> 值来添加精灵，或是进行其他的计算。</p>
<h2 id='image-next'>Go for the next</h2>
<p>到此，BKE的图像部分介绍就算告一个段落了。</p>
<p>不过还是那句话：这还只是冰山的一部分。剩下的冰山会随着之后我们的不断深度而露出它的全貌的，等不及的同学可以自己先学习一下:D</p>
<p>感谢阅读本章教程，我们下一章见~</p><h1 id='sound'>音频播放</h1>
<hr />
<p>本章将为您介绍关于BKE的音频播放部分。</p>
<p>音频文件可以通过音频相关命令来播放，常用的有 <code>bgm</code> , <code>se</code> , <code>voice</code> 等命令。</p>
<p>BKE引擎支持wav、ogg与mp3等常用格式的音频文件。鉴于现在各种各样的转换器的普及，将音频文件从原格式转换到质量较高的wav格式或者是压缩率较高的ogg格式都已经不存在太大的技术困难了，因此我们这里也不再赘述其中的细节。</p>
<p>对于音频系列的命令来说，BKE中还存在着<strong>频道</strong>的概念。有的时候，您可能希望同时能播放多个音效文件，这个时候您就需要使用不同的频道来控制这些文件的播放以及停止。而 <code>bgm</code> 和 <code>voice</code> 对应的背景音乐和语音一般不会同时播放多个文件，因此都只占用一个频道。</p>
<p>默认情况下，<code>bgm</code> 命令对应的频道编号是-1，而 <code>voice</code> 命令对应的频道编号是-2。 <code>se</code> 命令无法使用编号小于0的频道（包括 <code>bgm</code> 频道和 <code>voice</code> 频道），这将有助于减少潜在的混乱和错误。</p>
<p>除此之外，您可以使用 <code>volume</code> 命令调整频道的音量。 <code>pause</code> 命令和 <code>resume</code> 命令允许您暂停和继续播放某个频道的音频文件，而 <code>fade</code> 命令可以为您实现音量平滑变化的声音效果。</p>
<h2 id='sound-play'>播放命令</h2>
<p>如果您想播放任何音频文件，您必须从 <code>bgm</code> , <code>se</code> , <code>voice</code> 三个命令中选择一个合适的命令来使用。 <code>bgm</code> 命令适合播放游戏的背景音乐， <code>voice</code> 命令适合播放人物语音，而 <code>se</code>命令适合播放其他任何需要播放的音频文件。</p>
<p>&emsp;&emsp;<strong>bgm</strong>  <em>*file loop=true vol=100 fadein=0 loopto=0</em><br>
&emsp;&emsp;在bgm频道播放指定的音频文件。</p>
<p>&emsp;&emsp;&emsp;<em>*file</em> - 字符串<br>
&emsp;&emsp;&emsp;&emsp;&emsp;将要播放的文件。<br>
&emsp;&emsp;&emsp;<em>loop=false</em> - 布尔值<br>
&emsp;&emsp;&emsp;&emsp;&emsp;是否循环，默认为false。<br>
&emsp;&emsp;&emsp;<em>vol=100</em> - 音量型<br>
&emsp;&emsp;&emsp;&emsp;&emsp;播放音量，范围为0~100。<br>
&emsp;&emsp;&emsp;<em>fadein=0</em> - 时间型<br>
&emsp;&emsp;&emsp;&emsp;&emsp;淡入时间。若该数值不为0，那么淡入开始时音量将自动被设置为0。<br>
&emsp;&emsp;&emsp;<em>loopto=0</em> - 时间型<br>
&emsp;&emsp;&emsp;&emsp;&emsp;当音频播放结束时，若loop参数为true，那么将自动从该时间点开始重复播放。<br></p>
<p>&emsp;&emsp;<strong>se</strong>  <em>*file channel=0 loop=false vol=100 fadein=0</em><br>
&emsp;&emsp;在指定的频道播放指定的音频文件。该命令不接受loopto参数，因此不支持从音频的某一点重复播放功能。</p>
<p>&emsp;&emsp;&emsp;<em>*file</em> - 字符串<br>
&emsp;&emsp;&emsp;&emsp;&emsp;将要播放的文件。<br>
&emsp;&emsp;&emsp;<em>channel=0</em> - 整数型<br>
&emsp;&emsp;&emsp;&emsp;&emsp;将要使用的频道编号。<strong>不能是负数</strong>。在此文件播放前BKE将停止该频道当前正在播放的音频。<br>
&emsp;&emsp;&emsp;<em>loop=false</em> - 布尔值<br>
&emsp;&emsp;&emsp;&emsp;&emsp;是否循环，默认为false。<br>
&emsp;&emsp;&emsp;<em>vol=100</em> - 音量型<br>
&emsp;&emsp;&emsp;&emsp;&emsp;播放音量，范围为0~100。<br>
&emsp;&emsp;&emsp;<em>fadein=0</em> - 时间型<br>
&emsp;&emsp;&emsp;&emsp;&emsp;淡入时间。若该数值不为0，那么淡入开始时音量将自动被设置为0。<br></p>
<p>&emsp;&emsp;<strong>voice</strong>  <em>*file  vol=100</em><br>
&emsp;&emsp;在voice频道播放指定的音频文件。不能重复播放该频道的音频文件，也不能设置淡入效果。</p>
<p>&emsp;&emsp;&emsp;<em>*file</em> - 字符串<br>
&emsp;&emsp;&emsp;&emsp;&emsp;将要播放的文件。<br>
&emsp;&emsp;&emsp;<em>vol=100</em> - 音量型<br>
&emsp;&emsp;&emsp;&emsp;&emsp;播放音量，范围为0~100。<br></p>
<p>在实践中，如果您希望分开管理每个角色的语音音量，我建议您新建一个字典，并将各个角色的音量值保存到该字典的值中，用角色名称作为键，然后在调用voice命令的时候直接将vol参数的值设为该字典中相应角色的值即可。您也可以重新实现voice命令来达到您要的效果。</p>
<p>范例代码：</p>
<pre><code>@bgm file=&quot;bgm/bgm01.ogg&quot; vol=80 fadein=1000 loopto=30000
//以80的音量播放bgm，1秒淡入时间，播放完成后loop到30秒处重复播放
@se file=&quot;se/car.ogg&quot;
//播放se
@voice file=&quot;voice/nanami08213.ogg&quot;
//播放语音
</code></pre>

<h2 id='sound-control'>音频控制命令</h2>
<p>以下这些命令可以控制音频流，以及某频道的音量大小。</p>
<p>&emsp;&emsp;<strong>pause</strong>  <em>*channel</em> <br>
&emsp;&emsp;暂停一个频道，使用resume命令可以从当前位置继续播放该音频。<br>
&emsp;&emsp;&emsp;<em>*channel</em> - 整数型<br>
&emsp;&emsp;&emsp;&emsp;&emsp;将要暂停的频道编号。可以直接填bgm和se（非字符串），系统会自动完成正确的操作。如果希望暂停se频道，您需要提供确切的编号。<br></p>
<p>&emsp;&emsp;<strong>resume</strong>  <em>*channel</em> <br>
&emsp;&emsp;继续播放一个因pause命令停止播放的频道。<br>
&emsp;&emsp;&emsp;<em>*channel</em> - 整数型<br>
&emsp;&emsp;&emsp;&emsp;&emsp;将要继续播放的频道编号。可以直接填bgm和se（非字符串），系统会自动完成正确的操作。如果希望继续播放se频道，您需要提供确切的编号。<br></p>
<p>&emsp;&emsp;<strong>stop</strong>  <em>channel fadeout=0</em> <br>
&emsp;&emsp;停止一个频道，当channel参数不存在时将停止所有频道。<br>
&emsp;&emsp;&emsp;<em>channel</em> - 整数型<br>
&emsp;&emsp;&emsp;&emsp;&emsp;将要停止的频道编号。若不存在则会停止所有频道。<br>
&emsp;&emsp;&emsp;<em>fadeout=0</em> - 时间型<br>
&emsp;&emsp;&emsp;&emsp;&emsp;淡出的毫秒数。默认为0。<br></p>
<p>&emsp;&emsp;<strong>volume</strong>  <em>*channel get/set</em> <br>
&emsp;&emsp;调整或者获取一个频道的音量大小，瞬间完成。<strong>get和set参数至多且至少存在一个</strong>。<br>
&emsp;&emsp;&emsp;<em>channel</em> - 整数型<br>
&emsp;&emsp;&emsp;&emsp;&emsp;将要处理的频道编号。<br>
&emsp;&emsp;&emsp;<em>set</em> - 音量型<br>
&emsp;&emsp;&emsp;&emsp;&emsp;目标音量。<br>
&emsp;&emsp;&emsp;<em>get</em> - 变量<br>
&emsp;&emsp;&emsp;&emsp;&emsp;目标变量。频道的音量值将保存到这个变量里。<br></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在其他命令的参数中，您也会遇到类似的get/set参数组。您只需要记住，如果您要使用这类命令，只须提供set和get中的一个即可。</p>
<p>&emsp;&emsp;<strong>fade</strong>  <em>*channel *time *to stop=false</em> <br>
&emsp;&emsp;将一个频道的音量渐变到给定值。<br>
&emsp;&emsp;&emsp;<em>channel</em> - 整数型<br>
&emsp;&emsp;&emsp;&emsp;&emsp;将要渐变的频道编号。<br>
&emsp;&emsp;&emsp;<em>*time</em> - 时间型<br>
&emsp;&emsp;&emsp;&emsp;&emsp;渐变的毫秒数。<br>
&emsp;&emsp;&emsp;<em>to</em> - 音量型<br>
&emsp;&emsp;&emsp;&emsp;&emsp;目标音量。<br>
&emsp;&emsp;&emsp;<em>stop=false</em> - 布尔值<br>
&emsp;&emsp;&emsp;&emsp;&emsp;渐变完成后是否停止播放，默认为false。<br></p><h1 id='animation'>动画</h1>
<hr />
<p>这一次给各位介绍的是BKE的动画类，它包含了 <code>animate</code> 、 <code>action</code> 与 <code>trans</code> 。三者都是在BKE中制作动画时必不可缺的组成部分。
虽然实际说来三者其实是不同的三个类，不过考虑到功能划分，我们这一次就先对 <code>animate</code> 类先进行说明。</p>
<h2 id='animation-animate'>animate</h2>
<p>顾名思义，<code>animate</code> 命令常被用于创建逐帧动画时使用，您可以利用此命令来创建一个循环播放的动画。</p>
<p>其命令格式如下：</p>
<p>&emsp;&emsp;<strong>animate</strong> <em>*mode</em><br>
&emsp;&emsp;&emsp;&emsp;动画系命令关键字。</p>
<p>&emsp;&emsp;&emsp;<em>mode</em><br>
&emsp;&emsp;&emsp;&emsp;接下来执行动画命令的类型。<br></p>
<p><code>animate</code> 命令有6种不同的模式（mode关键字），它们分别是：</p>
<pre><code>horizontal vertical multfiles start cell stop
</code></pre>

<p>对于不同的 <code>mode</code> ， <code>animate</code> 命令有不同的参数，这里就向大家顺序介绍一下：</p>
<p>&emsp;&emsp;<strong>animate</strong> <em>*mode=&quot;horizontal&quot; *index *file *frame interval loop</em><br>
&emsp;&emsp;&emsp;&emsp;动画系命令，模式为剪裁方式（动画帧水平排列）。</p>
<p>&emsp;&emsp;&emsp;<em>index</em><br>
&emsp;&emsp;&emsp;&emsp;创建的动画的编号（和精灵共用一个编号集合）。<br>
&emsp;&emsp;&emsp;<em>file</em> <br>
&emsp;&emsp;&emsp;&emsp;读取的文件。<br>
&emsp;&emsp;&emsp;<em>frame</em><br>
&emsp;&emsp;&emsp;&emsp;动画的帧数。<br>
&emsp;&emsp;&emsp;<em>interval<em><br>
&emsp;&emsp;&emsp;&emsp;每帧的间隔，默认为33（30fps）。<br>
&emsp;&emsp;&emsp;</em>loop</em><br>
&emsp;&emsp;&emsp;&emsp;动画循环模式，值有 &quot;none&quot;（不循环），&quot;forword&quot;（单向循环），&quot;bouncing&quot;（布朗斯循环）。<br>
<br></p>
<hr />
<p>&emsp;&emsp;<strong>animate</strong> <em>*mode=&quot;vertical&quot; *index *file *frame interval loop</em><br>
&emsp;&emsp;&emsp;&emsp;动画系命令，模式为垂直模式（动画帧垂直排列）。</p>
<p>&emsp;&emsp;&emsp;<em>index</em><br>
&emsp;&emsp;&emsp;&emsp;创建的动画的编号（和精灵共用一个编号集合）。<br>
&emsp;&emsp;&emsp;<em>file</em> <br>
&emsp;&emsp;&emsp;&emsp;读取的文件。<br>
&emsp;&emsp;&emsp;<em>frame</em><br>
&emsp;&emsp;&emsp;&emsp;动画的帧数。<br>
&emsp;&emsp;&emsp;<em>interval<em><br>
&emsp;&emsp;&emsp;&emsp;每帧的间隔，默认为33（30fps）。<br>
&emsp;&emsp;&emsp;</em>loop</em><br>
&emsp;&emsp;&emsp;&emsp;动画循环模式，值有 &quot;none&quot;（不循环），&quot;forword&quot;（单向循环），&quot;bouncing&quot;（布朗斯循环）。<br></p>
<script language=JavaScript>
var number=1; 
function LMYC() {
var lbmc;
    for (i=1;i<=number;i++) {
        lbmc = eval('LM' + i);
        lbmc.style.display = 'none';
    }
}
 
function ShowFLT(i) {
    lbmc = eval('LM' + i);
    if (lbmc.style.display == 'none') {
        LMYC();
        lbmc.style.display = '';
    }
    else {
        lbmc.style.display = 'none';
    }
}
</script>
<table width="600" border="0" cellspacing="2" cellpadding="0">
  <tr>
    <td width="56" height="40" align="right" class="STYLE1">+</td>
    <td width="544" height="40" class="dotline"><a onClick=javascript:ShowFLT(1) href="javascript:void(null)">不同循环模式的说明</a></td>
  </tr>
  <tr id=LM1 style="DISPLAY: none">
    <td height="30" align="right" bgcolor="#f5f9ed"><span class="STYLE2">_</span></td>
    <td height="30" bgcolor="#f5f9ed">
	在假定一个动画文件有4帧的情况下：<br>
		&emsp;&emsp;不循环：顾名思义，动画将不会循环，仅仅只是按顺序1-2-3将动画播放一次后停止。<br>
		&emsp;&emsp;单向循环：动画会按照1-2-3-4｜1-2-3-4｜1-2-3-4这样的顺序来循环播放，在播放完最后一帧后重新跳转到第一帧。<br>
		&emsp;&emsp;布朗斯循环：在没有delay的情况下，动画会按照1-2-3-4-3-2-1-2-3-4的顺序循环；如果在有delay的情况下，动画则会按照1-2-3-4-3-2-1｜2-3-4-3-2-1｜2-3-4-3-2-1这样的顺序循环。<br>
	</td>
  </tr>
</table>
<p>在这里我们准备了两张不同的素材，以分别对应两种不同的剪裁模式：</p>
<p><br>
<center><img src="guide/images/rakuda-1.png" alt="horizontal" /></center>
<center><img src="guide/images/rakuda-3.png" alt="vertical" /></center></p>
<p>文件一对应了 <code>horizontal</code> 模式，而文件二对应的则是 <code>vertical</code> 模式。可以直观的看出前者是横向剪裁，后者则是竖向剪裁。</p>
<p>请您先将这两个文件保存下来，在之后的示例中我们将会使用到它。</p>
<p>接下来我们继续介绍剩余的模式：</p>
<p>&emsp;&emsp;<strong>animate</strong> <em>*mode=&quot;multifiles&quot; *index *file interval loop delay</em><br>
&emsp;&emsp;&emsp;&emsp;从多个文件创建一个动画。</p>
<p>&emsp;&emsp;&emsp;<em>index</em><br>
&emsp;&emsp;&emsp;&emsp;创建的动画的编号（和精灵共用一个编号集合）。<br>
&emsp;&emsp;&emsp;<em>file</em> <br>
&emsp;&emsp;&emsp;&emsp;将要添加的文件列表。<br>
&emsp;&emsp;&emsp;<em>interval</em><br>
&emsp;&emsp;&emsp;&emsp;每帧的间隔，默认为33（30fps）。<br>
&emsp;&emsp;&emsp;<em>loop<em><br>
&emsp;&emsp;&emsp;&emsp;动画是否循环，默认为 false 。<br>
&emsp;&emsp;&emsp;</em>delay</em><br>
&emsp;&emsp;&emsp;&emsp;动画每次循环之间的间隔 。<br></p>
<hr />
<p>&emsp;&emsp;<strong>animate</strong> <em>*mode=&quot;start&quot; *index</em><br>
&emsp;&emsp;&emsp;&emsp;开始一个动画。</p>
<p>&emsp;&emsp;&emsp;<em>index</em><br>
&emsp;&emsp;&emsp;&emsp;欲开始的动画的编号（和精灵共用一个编号集合）。<br></p>
<p>&emsp;&emsp;<strong>animate</strong> <em>*mode=&quot;stop&quot; *index</em><br>
&emsp;&emsp;&emsp;&emsp;停止一个动画。</p>
<p>&emsp;&emsp;&emsp;<em>index</em><br>
&emsp;&emsp;&emsp;&emsp;欲停止的动画的编号（和精灵共用一个编号集合）。<br></p>
<hr />
<p>&emsp;&emsp;<strong>animate</strong> <em>*mode=&quot;cell&quot; *index *frame</em><br>
&emsp;&emsp;&emsp;&emsp;切换动画到某一帧（会停止动画）。</p>
<p>&emsp;&emsp;&emsp;<em>index</em><br>
&emsp;&emsp;&emsp;&emsp;欲更改的动画的编号（和精灵共用一个编号集合）。<br>
&emsp;&emsp;&emsp;<em>file</em> <br>
&emsp;&emsp;&emsp;&emsp;欲更改动画到哪一帧。<br></p>
<pre><code>请注意， `start` 仅仅只能作用于单个精灵，不能传入数组作为参数。
</code></pre>

<p>在介绍完 <code>animate</code> 类所有的 <code>mode</code> 之后，让我们来练练手吧！</p>
<p>首先请将下面的图片保存到您的硬盘上：</p>
<p><center><img src="guide/images/ch-1.png" alt="ch1" />&emsp;&emsp;<img src="guide/images/ch-2.png" alt="ch2" />&emsp;&emsp;<img src="guide/images/ch-3.png" alt="ch3" /></center></p>
<p>接着，您可以直接复制下面的代码，保存编译之后运行以查看它的作用，不过我还是推荐您自己先写一遍 :)</p>
<pre><code>*main
@layer index=10 width=800 height=600 color=0xFFFFFF opacity=255
@addto index=10 target=basic_layer
@wait time=1000 canskip=false

@animate mode=&quot;horizontal&quot; index=2 file=&quot;rakuda-1&quot; frame=4 interval=180 loop=&quot;forward&quot;
@addto index=2 target=10 zorder=10 pos=[250,280]
@animate mode=&quot;start&quot; index=2
@wait time=1000 canskip=false

@animate mode=&quot;vertical&quot; index=3 file=&quot;rakuda-3&quot; frame=4 interval=360 loop=&quot;forward&quot;
@addto index=3 target=10 zorder=10 pos=[350,280]
@animate mode=&quot;start&quot; index=3
@wait time=1000 canskip=false

@animate mode=&quot;multifiles&quot; index=4 file=[&quot;ch-1&quot;,&quot;ch-2&quot;,&quot;ch-3&quot;] interval=360 loop=&quot;true&quot; delay=500
@addto index=4 target=10 zorder=10 pos=[400,280]
@animate mode=&quot;start&quot; index=4
@wait time=2000 canskip=false

@animate mode=&quot;stop&quot; index=2
@animate mode=&quot;cell&quot; index=3 frame=2
</code></pre>

<p>首先，我们使用两张连续的图片创建了两个动画，分别对应的是横向剪裁模式与竖向剪裁模式。在每一次创建结束后，我们都使用了 <code>start</code> 模式来开始对应的动画，如果我们不使用 <code>start</code> 命令，对应的动画则不会开始播放，请注意。</p>
<p>接下来我们使用了 <code>muiltfiles</code> 模式，以三张独立的图片创建了一个动画。这里需要说明的是，在 <code>muiltfiles</code> 模式中， <code>interval</code> 这个参数负责控制帧与帧之间的间隔时间，而 <code>delay</code> 参数则用于控制每次循环与循环之间的间隔时间。您可以自行修改 <code>delay</code> 的大小来体会。</p>
<p>在最后两行命令中，我们停止了编号为2的动画文件的播放，使编号为3的动画切换到了第2帧（注意，这样做会停止动画的播放）。</p>
<p>以上就是 <code>animate</code> 类的所有命令了，怎么样，是不是觉得很简单呢？</p>
<p><code>animate</code> 类的用处很广泛，您可以使用动画文件来创建一个动态的按钮，或者是在画面上循环一段动画，加强您游戏的演出效果等，甚至您还可以使用它来制作RPG类游戏的NPC！</p>